<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>ChatRWS — Reflection Without Surveillance</title>
  <style>
    :root {
      --bg:#f6f7f9;
      --panel:#ffffffcc;
      --line:#e9ebef;
      --text:#101216;
      --muted:#6b7280;
      --bubble:#ffffff;
      --shadow:0 10px 30px rgba(0,0,0,.06);
      --accent:#10a37f;
      --accent-hover:#0e8c6e;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg:#0f1115;
        --panel:#0f1115cc;
        --line:#1b2027;
        --text:#e7e9ee;
        --muted:#9aa4b2;
        --bubble:#151923;
        --shadow:0 10px 30px rgba(0,0,0,.35);
        --accent:#19c287;
        --accent-hover:#0fb97f;
      }
    }

    * { box-sizing:border-box; }
    html,body { height:100%; }
    body {
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:16px/1.5 system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      display:flex; flex-direction:column;
    }

    header {
      position:sticky; top:0; z-index:2;
      background:var(--panel);
      backdrop-filter:blur(10px) saturate(140%);
      -webkit-backdrop-filter:blur(10px) saturate(140%);
      border-bottom:1px solid var(--line);
    }
    .bar {
      max-width:920px; margin:0 auto; padding:14px 16px;
      display:flex; justify-content:space-between; align-items:center;
    }
    .title {
      font-size:18px;
      font-weight:700;
      letter-spacing:0.01em;
      color:var(--text);
    }
    .ephemeral { font-size:12px; color:var(--muted); }

    .wrap { flex:1; display:flex; flex-direction:column; max-width:920px; margin:0 auto; width:100%; padding:16px; }
    .chat {
      flex:1; overflow:auto; padding:16px;
      border:1px solid var(--line); border-radius:24px;
      background:linear-gradient(180deg, rgba(255,255,255,.45), rgba(255,255,255,.35));
      box-shadow:var(--shadow);
    }

    .row { display:flex; margin:10px 0; }
    .row.you { justify-content:flex-end; }
    .bubble {
      max-width:72ch; padding:12px 14px; border-radius:14px 14px 4px 14px;
      background:var(--bubble); border:1px solid var(--line); position:relative;
    }
    .row.you .bubble { border-radius:14px 14px 14px 4px; }
    .meta { font-size:12px; color:var(--muted); margin-top:6px; user-select:none; }

    /* Evaporation */
    .evaporating { animation: bubbleFade .9s ease forwards; }
    @keyframes bubbleFade { to { opacity:.2; transform:translateY(-6px); } }
    .chars { display:inline; }
    .ch { display:inline-block; }
    .evaporating .ch { animation: rise var(--dur,900ms) ease-out var(--delay,0ms) forwards; }
    @keyframes rise {
      to { transform:translate(var(--dx,0px), calc(-1 * var(--lift,36px))) rotate(var(--rot,0deg)) scale(.96); opacity:0; filter:blur(2px); }
    }

    .composer {
      display: flex;
      align-items: center; /* center vertically */
      justify-content: center; /* optional: center horizontally too */
      gap: 8px;
      padding: 12px 0;
      position: relative;
    }
    textarea {
      flex:1; resize:none; min-height:60px; max-height:220px; padding:12px 14px;
      border:1px solid var(--line); border-radius:16px; background:var(--bubble); color:var(--text);
      outline:none; transition:border-color .2s ease;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    }
    textarea:focus { border-color:var(--accent); }

    /* ChatGPT-style upward Release button */
    button {
      background:var(--accent); color:#fff; border:none; border-radius:50%;
      width:42px; height:42px; display:flex; align-items:center; justify-content:center; cursor:pointer; flex-shrink:0;
      transition:background .2s ease, transform .1s ease, box-shadow .2s ease;
      box-shadow:0 2px 6px rgba(0,0,0,0.15);
    }
    button:hover { background:var(--accent-hover); box-shadow:0 0 0 3px rgba(16,163,127,0.25); }
    button:active { transform:translateY(1px) scale(0.97); }

    button svg, button svg * { transform:none !important; }

    button svg {
      width:18px; height:18px;
      stroke:#fff; fill:none; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;
    }

    .chars { display:block; white-space:pre-wrap; }
    .bubble { word-break: break-word; }

    .foot {
      font-size:12px; color:var(--muted); text-align:center; margin:10px 0 0 0;
      border-top:1px dashed var(--line); padding-top:10px; user-select:none;
    }

    /* Centered state (default) — fixed, glassy, and elevated */
.composerWrap {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: min(920px, calc(100% - 32px));
  z-index: 3;
  transition: transform .3s ease, top .3s ease, bottom .3s ease, opacity .25s ease;
  background: var(--panel);
  backdrop-filter: blur(10px) saturate(140%);
  -webkit-backdrop-filter: blur(10px) saturate(140%);
  border: 1px solid var(--line);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 12px;
}

/* Make the internal bar look tidy when floating */
.composer { padding: 0; }

/* Docked state — behaves like ChatGPT’s bottom bar */
.docked .composerWrap {
  position: sticky;
  left: auto;
  top: auto;
  bottom: 0;
  transform: none;
  width: 100%;
  background: var(--panel);
  border-radius: 16px;
  padding: 12px 16px;
}

/* Give the chat area breathing room when docked */
.docked .chat { padding-bottom: 90px; }

/* Optional: subtle divider on docked bar */
.docked .composerWrap { border-top: 1px solid var(--line); }


/* Hide chat and footer until first message */
.prechat .chat {
  opacity: 0;
  height: 0;
  overflow: hidden;
  padding: 0;
  margin: 0;
  border-width: 0;
}
.prechat .foot {
  display: none;
}

/* Center composer initially */
.composerWrap {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: min(920px, calc(100% - 32px));
  z-index: 3;
  transition: transform .3s ease, top .3s ease, bottom .3s ease, opacity .25s ease;
  background: var(--panel);
  backdrop-filter: blur(10px) saturate(140%);
  -webkit-backdrop-filter: blur(10px) saturate(140%);
  border: 1px solid var(--line);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 12px;
}

/* Docked (after first send) */
.docked .composerWrap {
  position: sticky;
  left: auto;
  top: auto;
  bottom: 0;
  transform: none;
  width: 100%;
  background: var(--panel);
  border-radius: 16px;
  padding: 12px 16px;
  border-top: 1px solid var(--line);
}
.docked .chat { padding-bottom: 90px; }

/* --- Mobile layout & type scaling --- */
@media (max-width: 768px) {
  html, body { font-size: 18px; -webkit-text-size-adjust: 100%; } /* readable + avoid input zoom */
  .wrap { padding: 8px; }
  .bar { padding: 12px 12px; }
  .title { font-size: 16px; }
  .ephemeral { font-size: 12px; }

  .chat {
    padding: 12px;
    border-radius: 16px;
  }

  /* Force the composer to the bottom on mobile (even before first send) */
  .composerWrap {
    position: sticky;
    left: auto; top: auto; bottom: 0;
    transform: none;
    width: 100%;
    border-radius: 16px 16px 0 0;
    padding: 12px env(safe-area-inset-right) calc(12px + env(safe-area-inset-bottom)) env(safe-area-inset-left);
  }

  /* Show chat on first load on mobile */
  .prechat .chat {
    opacity: 1; height: auto; overflow: auto;
    padding: 12px;
    margin: 0;
    border-width: 1px;
  }
  .prechat .foot { display: block; }

  /* Extra bottom space so the docked bar doesn’t cover last messages */
  .chat { padding-bottom: calc(110px + env(safe-area-inset-bottom)); }
  .docked .chat { padding-bottom: calc(110px + env(safe-area-inset-bottom)); }

  .composer { gap: 10px; }

  textarea {
    min-height: 56px;          /* large enough to avoid iOS zoom on focus */
    font-size: 18px;            /* >=16px prevents zoom */
    line-height: 1.5;
  }

  button { width: 48px; height: 48px; } /* comfortable tap target */
  button svg { width: 20px; height: 20px; }
}

/* ---- Theme tokens (light & dark) ---- */
:root {
  color-scheme: light dark;           /* lets the browser style form controls per mode */
  --bg: #ffffff;                      /* page background (light)  */
  --fg: #0b0b0c;                      /* text (light)            */
  --border: #e6e6eb;                  /* subtle borders (light)  */
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #0b0b0c;                    /* page background (dark)  */
    --fg: #eaeaea;                    /* text (dark)             */
    --border: #222;                   /* subtle borders (dark)   */
  }
}

/* Apply everywhere */
html, body { background: var(--bg); color: var(--fg); }

/* Make the chat area blend with the page in BOTH modes */
.chat {
  background: var(--bg) !important;   /* same as body */
  border: 1px solid var(--border) !important;  /* keep your rounded card edge, optional */
  box-shadow: none !important;        /* remove any grey/raised look */
  background-clip: padding-box;       /* avoid odd blending halos */
}

/* If your layout has a wrapper or card behind .chat, match it too */
.wrap, .chat-container { background: var(--bg) !important; }

/* Safety: kill any decorative overlays that might be tinting it grey */
.chat::before,
.chat::after { background: transparent !important; box-shadow: none !important; }


  </style>
</head>
<body class="prechat">

  <header>
    <div class="bar">
      <div class="title"><strong>ChatRWS v1</strong> - Reflect Without Surveillance</div>
      <div class="ephemeral">Local only · Nothing stored or analyzed</div>
    </div>
  </header>

  <main class="wrap">
    <div id="chat" class="chat"></div>

    <!-- Add this wrapper -->
    <div class="composerWrap">
      <div class="composer">
        <textarea id="input" placeholder="How are you feeling? Press Enter to release the thought."></textarea>
        <button id="send" title="Release" aria-label="Release">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <polyline points="6 10 12 4 18 10"></polyline>
            <line x1="12" y1="4" x2="12" y2="20"></line>
          </svg>
        </button>
      </div>
    </div>



    <div class="foot">
      This chat mirrors feelings without replying.<br>
      Unlike LLMs, it offers no affirmation loop. Language lives only long enough to let go.
    </div>
  </main>

  <script>
  let isDocked = false;

  function dockComposer() {
    if (isDocked) return;
    document.body.classList.remove('prechat'); // show chat window
    document.body.classList.add('docked');     // dock composer
    isDocked = true;
  }


    const chat = document.getElementById('chat');
    const input = document.getElementById('input');
    const send = document.getElementById('send');

    function autosize(el){
      el.style.height='auto';
      el.style.height=Math.min(220, el.scrollHeight)+'px';
    }
    input.addEventListener('input',()=>autosize(input));

    function splitToCharSpans(text){
      const spanWrap = document.createElement('span');
      spanWrap.className = 'chars';
      for (const ch of text.replace(/\r/g,'')) {
        if (ch === '\n') { spanWrap.appendChild(document.createElement('br')); continue; }
        const s = document.createElement('span');
        s.className = 'ch';
        if (ch === ' ') {
          s.innerHTML = '&nbsp;';
        } else if (ch === '\t') {
          s.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;';
        } else {
          s.textContent = ch;
        }
        spanWrap.appendChild(s);
      }
      return spanWrap;
    }

    function randomizeEvaporation(bubble){
      const chars=bubble.querySelectorAll('.ch');
      const baseLift=36;
      chars.forEach(el=>{
        const dx=(Math.random()-0.5)*24;
        const delay=80+Math.random()*420;
        const dur=500+Math.random()*900;
        const rot=(Math.random()-0.5)*8;
        el.style.setProperty('--dx',dx.toFixed(2)+'px');
        el.style.setProperty('--lift',(baseLift+Math.random()*22).toFixed(2)+'px');
        el.style.setProperty('--delay',delay.toFixed(0)+'ms');
        el.style.setProperty('--dur',dur.toFixed(0)+'ms');
        el.style.setProperty('--rot',rot.toFixed(2)+'deg');
      });
    }

    function addMessage(text){
      if(!text.trim()) return;
      const row=document.createElement('div');
      row.className='row you';
      const bubble=document.createElement('div');
      bubble.className='bubble';
      bubble.appendChild(splitToCharSpans(text));
      const meta=document.createElement('div');
      meta.className='meta';
      meta.textContent=new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
      bubble.appendChild(meta);
      row.appendChild(bubble);
      chat.appendChild(row);
      chat.scrollTo({top:chat.scrollHeight, behavior:'smooth'});
      setTimeout(()=>{
        randomizeEvaporation(bubble);
        bubble.classList.add('evaporating');
        setTimeout(()=>row.remove(),3000);
      },5000);
    }

    function handleSend(){
      const text = input.value;
      addMessage(text);
      input.value='';
      autosize(input);
      input.focus();
      dockComposer(); // move composer & reveal chat
    }


    send.addEventListener('click',handleSend);
    input.addEventListener('keydown',e=>{
      if(e.key==='Enter'&&!e.shiftKey){ e.preventDefault(); handleSend(); }
    });

    // On load, force docked layout on small screens
(function () {
  const mq = window.matchMedia('(max-width: 768px)');
  function applyMobileDock() {
    if (mq.matches) {
      document.body.classList.add('docked');
      document.body.classList.remove('prechat'); // reveal chat on mobile immediately
    }
  }
  applyMobileDock();
  mq.addEventListener?.('change', applyMobileDock);
})();

    (function () {
  const form = document.querySelector('.composer form') || document.querySelector('#composerForm');
  const textarea = document.querySelector('.composer textarea') || document.querySelector('#msg');
  const releaseBtn = document.querySelector('.composer button');

  if (!textarea) return;

  function hideKeyboard() {
    // Works on most browsers
    textarea.blur();

    // iOS Safari can be stubborn—this forces the keyboard to close
    textarea.setAttribute('readonly', 'readonly');
    setTimeout(() => {
      textarea.removeAttribute('readonly');
    }, 50);

    // Nudge viewport so toolbar collapses
    setTimeout(() => window.scrollTo(0, 0), 0);
  }

  // If you have a submit flow:
  if (form) {
    form.addEventListener('submit', (e) => {
      // keep your existing submit logic…
      // e.g., e.preventDefault(); releaseMessage(textarea.value);

      hideKeyboard();
    }, true);
  }

  // Also blur when the Release button is tapped (in case it’s a click handler, not a submit)
  if (releaseBtn) {
    releaseBtn.addEventListener('click', () => {
      hideKeyboard();
    }, true);
  }

  // Optional: tapping anywhere outside the composer hides the keyboard
  document.addEventListener('touchstart', (e) => {
    const composer = document.querySelector('.composerWrap') || document.querySelector('#composer');
    if (composer && !composer.contains(e.target)) hideKeyboard();
  }, { passive: true });
})();

  </script>
</body>
</html>
